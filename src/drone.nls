drones-own[
  incoming-queue
  finished? ; Is the goal reached ?
  leader?   ; car leading the convoi convoi
  to-protect? ; Should this car be protected at all cost ?
  genlongpath? ; Should the leader compute a new path (but not shortest) ?
  regenpath? ; doit - on regenerer le path (nouvelle info? ... )
  last-send-time ; communication historical time-stamp
  ;beliefs tous les agents ont le BDI ?
  ;intentions
  
  rand-path
  eli-path
  angle-eli
   carburant
  ammo
  cooldown-status
  armed?
  known-leader-drone
  debug-x
  debug-y
  
  ]



to setup-drones
  if total-nb-drones > 0 [
    ; get the size of the base to deploy the car accordingly
    let base-min-pxcor min [pxcor] of (patches with [base? and pzcor = mapAlt])
    let base-max-pxcor max [pxcor] of (patches with [base? and pzcor = mapAlt])
    let base-min-pycor min [pycor] of (patches with [base? and pzcor = mapAlt])
    let base-max-pycor max [pycor] of (patches with [base? and pzcor = mapAlt])

    ; creation des voitures du convoi et cortege
    create-drones total-nb-drones
    ask drones
    [
      ; Init apparence NetLogo
      set shape "airplane 2"
      set size 5
      ;set color magenta

      ; Init des structures BDI
      set incoming-queue [] ; Do not change

      ; Init vars convois
      set speed 0.1 * simu-speed
      set maxdir 10 * simu-speed
      set heading 0
      set roll 0
      set pitch 0
      set finished? false
      set leader? false
      set to-protect? false
      set genlongpath? false
      set dead? false
      set regenpath? false
      set hp drones-hp
      
      set angle-eli random 360
      set eli-path  []
      
      set range-visu drone-range
      set range drone-range
      set range-color drone-range-color
      
      set cooldown-status 0 ;; Rechargement de l'arme
      set armed? true
      set ammo drones-max-ammo
      set rand-path []
     set message-to-forward []
      ; Visu
      set label who ; display the car names
      set known-leader-drone 5
      set size 3
      set carburant drones-max-carburant
    ]
    let first-drone min [who] of drones
    ask drone first-drone [
      move-to patch base-min-pxcor base-max-pycor 1
    ]
    
    ; deploying the other car
    if total-nb-drones > 1 [
      ; ask non leader cars
      ask turtle-set sort-on [who] drones with [who > first-drone]
      [
        let wwho  who - first-drone
        ifelse (who - 1) mod 2 = 0 [ set xcor base-min-pxcor ] [ set xcor base-min-pxcor + 1 ] ; a gauche ou a droite selon le nombre (pair ou impair respectivement)
        set ycor base-max-pycor - (floor (wwho / 2) / (total-nb-drones / 2) * (base-max-pycor - base-min-pycor)) ; d'une rangee de plus en plus basse toutes les deux voitures
        set zcor solAlt
      ]

    ]

  ]
end

to drones-think 
  ask drones [
    update-drone-from-ihm
   ;receive-message
   forward-messages
   if ticks = 0 [send-status]
   check-dead
  ]
  random-move-path-drones
  ;drone-eliptic-move
  drones-fire
   
end


to reload
  set ammo drones-max-ammo
end

to drones-fire
 ask drones [
   set cooldown-status max list (cooldown-status  - 1) 0 ;; On diminue le cooldown pour pouvoir tirer 
   let hostiles-in-range hostiles in-cone drone-range 360
   if count hostiles-in-range  > 0 [
     let cible one-of hostiles-in-range  
     if cooldown-status = 0 and ammo > 0[  ;; S'il y a un convoi dans le champ de vision ET qu'on peut tirer
       set cooldown-status cooldown ;; On met le cooldown au max
       facexyz [xcor] of cible [ycor] of cible [zcor] of cible
       shoot ;; On tire :-)
     ]
   ]
 ]
end


to random-move-path-drones ;Ici, l'idée c'est de générer un chemin vers un patch aléatoire et de s'y rendre
  ;let tmp-plan plan-astar patch-here one-of patches with [pzcor = 0 and not obstacle?] false

  if total-nb-drones > 0 [

    ; Calcul du plan AStar pour chaque hostile ayant atteint son arrivée
    foreach sort-on [who] turtle-set drones with [finished? and not dead?] [
      let id ([who] of ?) ;id pour gérer avec astar observer hors turtle context
      if [finished?] of (turtle id) [;si pas de chemin on génère
        let tmp-patch patch ([pxcor] of (turtle id)) ([pycor] of (turtle id)) ([pzcor] of (turtle id))
        let goal (one-of patches with [not obstacle?])
        let tmpplan plan-astar3D ( tmp-patch ) goal (false)
        ask turtle id [
          set rand-path tmpplan 
          if not empty? rand-path [
            set finished? false
          ]
        ]
      ]
    ]

      ;Déplacements selon les random-paths
      ask drones with [not finished? and not dead?] [ ; Tant qu'on n'a pas atteint le but

      ; Recupere le plan AStar
      if not empty? rand-path [
        ask last rand-path [set pcolor pink]
        ; Deplacement par waypoints: on se deplace jusqu'au prochain patch du chemin jusqu'à l'atteindre
        let next-patch first rand-path
        let zz pzcor
        ;set next-patch [patch-at 0 0 0] of next-patch ; mise a niveau de pzcor au cas ou le chemin a ete calculé sur un autre plan
        ; Deplacement vers le prochain waypoint
        if next-patch != patch-here [move-drone next-patch false false]
        ; Si on a atteint ce patch, on le supprime de la liste, et on va donc continuer vers le prochain patch du chemin
        if patch-here = next-patch [
          set rand-path remove-item 0 rand-path
          
        ]
      ]

      ; Critere d'arret: on est a cote de l'objectif
      if empty? rand-path[
        set finished? true
        ask patch-here [set pcolor red]
      ]
    ]


  ]
end


to drone-eliptic-move
  let u ([xcor] of convoi 0)
  let v ([ycor] of convoi 0)
  ask drones[
    ;set debug-x ([xcor] of convoi 0) ; Pas de poroblèmes avec la récupération des coordonnées.
    ;set debug-y ([ycor] of convoi 0)
    
    let xp cos(angle-eli) * elipseA * patch-size + u
    let yp sin(angle-eli) * elipseB * patch-size + v
    let pas sqrt ( (xp - xcor) ^ 2 + (yp - ycor) ^ 2 )
    set xp cos(angle-eli) * elipseA + u
    set yp sin(angle-eli) * elipseB + v
    ;set debug-x xp
    ;set debug-y yp
    ;if xp < 0
    ; [set xp 0]
    ;if xp > max-pxcor
    ; [set xp max-pxcor]
    ; if yp < 0
    ; [set yp 0]
    ; if yp > max-pxcor
    ; [set yp max-pxcor]
    facexy xp yp

    ;show pas
    fd speed
    set angle-eli angle-eli + 360 / pas
    set angle-eli angle-eli mod 360
  ]
end
;Marche mal, autre possibilité : créer une route à la volée suivant l'angle et les coords du convoi
;et la suivre avec l'algo de suivi de chemins, possibilté de reset la route tous les 360° pour afiner et plus simple pour wrap 
;    foreach sort-on [who] turtle-set drones with [finished? and not dead?] [
;      let id ([who] of ?) ;id pour gérer avec astar observer hors turtle context
;      if [finished?] of (turtle id) [;si pas de chemin on génère
;        let tmp-patch patch ([pxcor] of (turtle id)) ([pycor] of (turtle id)) ([pzcor] of (turtle id))
;        let goal compute-goal-eli id
;        let tmpplan plan-astar3D ( tmp-patch ) goal (false)
;        ask turtle id [
;          set eli-path tmpplan 
;          if not empty? eli-path [
;            set finished? false
;            set angle-eli angle-eli + 1
;          ]
;        ]
;      ]
;    ]
    
      ;Déplacements selon les random-paths
;      ask drones with [not finished? and not dead?] [ ; Tant qu'on n'a pas atteint le but

      ; Recupere le plan AStar
;      if not empty? eli-path [
        ; Deplacement par waypoints: on se deplace jusqu'au prochain patch du chemin jusqu'à l'atteindre
;        let next-patch first eli-path
;        let zz pzcor
;        set next-patch [patch-at 0 0 0] of next-patch ; mise a niveau de pzcor au cas ou le chemin a ete calculé sur un autre plan
        ; Deplacement vers le prochain waypoint
;        if next-patch != patch-here [move-drone next-patch false false]
        ; Si on a atteint ce patch, on le supprime de la liste, et on va donc continuer vers le prochain patch du chemin
;        if patch-here = next-patch [
;          set eli-path remove-item 0 eli-path
;        ]
;      ]

      ; Critere d'arret: on est a cote de l'objectif
;      if empty? eli-path[
;        set finished? true
;     ]
;    ]
        
;end

to-report compute-goal-eli [id]
        let px cos([angle-eli] of (turtle id)) * elipseA + ([xcor] of convoi 0)
        let py sin([angle-eli] of (turtle id)) * elipseB + ([ycor] of convoi 0)

        let goal patch px py 10 
        let goal-patch min-one-of (patches with [pzcor = 10 and not obstacle?]) [distance goal]
        report goal-patch
end


to move-drone [goal slowdown? cortege?]
  ;show (word "ici:" patch-here " goal:" goal)
  ; Calcule de l'angle avec la cible
  let headingFlag heading
  let pitchFlag pitch
  ifelse cortege?
  [ 
    set headingFlag (towards goal) 
    set pitchFlag (towards-pitch goal) 
  ] ; Si c'est un cortege, on veut qu'il suive toujours le leader par le chemin le plus court (surtout en play-mode ou le joueur n'est pas limite par le nowrap)
  [ 
    set headingFlag (towards-nowrap goal) 
    set pitchFlag (towards-pitch-nowrap goal) 
  ]
  let dirCorrection subtract-headings headingFlag heading
  let upCorrection subtract-headings pitchFlag pitch
  ; Arrondissement de l'angle (on ne veut pas faire de micro tournant)
  set dirCorrection precision dirCorrection 2
  set upCorrection precision upCorrection 2
  ; Limite de l'angle, pour que ce soit plus realiste (la voiture ne peut pas faire un demi-tour sur place!)
  ifelse dirCorrection > maxdir [ ; limite a droite
    set dirCorrection maxdir
  ]
  [
    if dirCorrection < maxdir * -1 [ ; limite a gauche
      set dirCorrection maxdir * -1
    ]
  ]
  

  ; On tourne
  right dirCorrection
  ;print upCorrection
  set pitch pitch + upCorrection
  

  ; Limite de vitesse pour les voitures-cortege (pour pas qu'elles ne rentrent dans la voiture leader)
  let tmp-speed speed
  if slowdown? [
    if distance-nowrap goal < 1.1 [
      set tmp-speed tmp-speed / 20
    ]
    if distance-nowrap goal < 0.9 [
      set tmp-speed 0
    ]
  ]

  ; Deplacement!
  ;set pitch 0 ; make sure there's no pitch ever, else the car will disappear in the ground
  fd tmp-speed ; Avance
end

to update-drone-from-ihm
  set range drone-range
  set range-color drone-range-color
end


;; Maj de l'etat d'une voiture du convoi quand ellle est touchée
to toucher-drone
  set hp hp - 1
  if hp = 5 [set color color - 2]
  if hp = 0 [ 
    set dead? true
    print word (word breed " ") (word (word who) " : Je suis Mort " )
    set nb-cars nb-cars - 1
    die
  ]
  
end






to check-dead
  if hp = 0 or carburant = 0[
    set dead? true
    print word (word breed " ") (word (word who) " : Je suis Mort " )
    die
  ]

end
