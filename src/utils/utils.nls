
to-report path-to-zone [path]
  let zone-path []
  foreach path
  [
    let p patch [pxcor] of ? [pycor] of ? mapAlt
    let z [z_zone] of p
    if empty? zone-path or not (compare-list last zone-path z)  
    [set zone-path lput z zone-path]
  ]
  ;print zone-path
  report zone-path
end


to-report in-zone? [p zone]
  ;print patch-to-zone p
  ;print zone
  ifelse compare-list ([z_zone] of p) zone
  [report true]
  [report false]
  
end

to-report pin-zone? [zone]
  ;print patch-to-zone p
  ;print zone
  ifelse compare-list z_zone zone
  [report true]
  [report false]
  
end


;to-report patch-to-zone [p]
;  let x int ([pxcor] of p / zone-size)
;  let y int ([pycor] of p / zone-size)
;  let dest (list x y 1)
;  report dest
;end
;
;to-report to-zone
;  let x int (pxcor / zone-size)
;  let y int (pycor / zone-size)
;  let dest (list x y 1)
;  report dest
;end

to-report get-zone
  
  report [z_zone] of myself
end



; Return the 6 neighbours without the world wrap
to-report neighbors6-nowrap
; reports neighbors-nowrap-n or the indicated size
report neighbors6 with
[ abs (pxcor - [pxcor] of myself) <= 1
  and abs (pycor - [pycor] of myself) <= 1
]
end


to-report neighbors-nowrap
; reports neighbors-nowrap-n or the indicated size
report neighbors with
[ abs (pxcor - [pxcor] of myself) <= 1
  and abs (pycor - [pycor] of myself) <= 1
  and abs (pzcor - [pzcor] of myself) <= 1
]
end


to-report compare-list [l1 l2]
  let i 0
  foreach l1 [ 
    ;print (word ? " " (item i l2))
    if (item i l2) != ? [report false] 
    set i i + 1
  ]
  report true 
end